syntax = "proto3";

package slurmx_grpc;

message Negotiation {
  uint32 version = 1;
}

// Match the definition of 'resource_t' in PublicHeader.h
message AllocatableResource {
  uint64 cpu_core_limit = 1;
  uint64 memory_limit_bytes = 2;
  uint64 memory_sw_limit_bytes = 3;
}

message ResourceAllocRequest {
  AllocatableResource required_resource = 1;
}

message ResourceAllocReply {
  bool ok = 1;
  oneof payload {
    bytes resource_uuid = 2;
    string reason = 3;
  }
}

message TaskInfo {
  string executive_path = 1;
  repeated string arguments = 2;

  bytes resource_uuid = 3;
}

message IoRedirection {
  string buf = 1;
}

message TaskExitStatus {
  enum ExitReason {
    Normal = 0;
    Signal = 1;
  }

  ExitReason reason = 1;
  uint32 value = 2;
}

message NewTaskResult {
  bool ok = 1;
  string reason = 2;
}

message SrunXStreamRequest{
  enum Type {
    Negotiation = 0;
    NewTask = 1;
    Signal = 2;
  }
  Type type = 1;

  oneof payload {
    Negotiation negotiation = 2;
    TaskInfo task_info = 3;
    uint32 signum = 4;
  }
}

message SrunXStreamReply {
  enum Type {
    IoRedirection = 0;
    ExitStatus = 1;
    NewTaskResult = 2;
  }
  Type type = 1;

  oneof payload {
    IoRedirection io_redirection = 2 ;
    TaskExitStatus task_exit_status = 3;
    NewTaskResult new_task_result = 4;
  }
}

message SlurmXdRegisterRequest {
  Negotiation header = 1;
  AllocatableResource resource_total = 2;
}

message SlurmXdRegisterResult {
  bool ok = 1;
  oneof payload {
    bytes uuid = 2; // always 16 bytes
    string reason = 3;
  }
}

message HeartbeatRequest {
  bytes node_uuid = 1;
}

message HeartbeatReply {}

message GrantResourceTokenRequest {
  bytes resource_uuid = 1;
  AllocatableResource allocated_resource = 2;
}

message GrantResourceTokenReply {
  bool ok = 1;
  string reason = 2;
}

message RevokeResourceTokenRequest {
  bytes resource_uuid = 1;
}

message RevokeResourceTokenReply {
  bool ok = 1;
  string reason = 2;
}

// Todo: Divide service into two parts: one for SlurmXd and one for SrunX
//  We need to distinguish the message sender
//  and have some kind of authentication
service SlurmCtlXd {
  rpc RegisterSlurmXd(SlurmXdRegisterRequest) returns (SlurmXdRegisterResult);
  rpc AllocateResource(ResourceAllocRequest) returns(ResourceAllocReply);
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatReply);
}

service SlurmXd {
  rpc GrantResourceToken(GrantResourceTokenRequest) returns (GrantResourceTokenReply);
  rpc RevokeResourceToken(RevokeResourceTokenRequest) returns (RevokeResourceTokenReply);

  rpc SrunXStream(stream SrunXStreamRequest) returns (stream SrunXStreamReply);
}
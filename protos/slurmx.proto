syntax = "proto3";

package SlurmxGrpc;

import "PublicDefs.proto";
import "google/protobuf/duration.proto";

message Negotiation {
  uint32 version = 1;
}

message NegotiationRequest {
  uint32 version = 1;
}

message NegotiationReply {
  bool ok = 1;
  string reason = 2; // Set when failed
}

message InteractiveTaskAllocRequest {
  Resources required_resources = 1;
  string partition_name = 2;
  uint64 time_limit_sec = 3;
}

message BasicTaskMeta {
  uint32 task_id = 1;
  bytes resource_uuid = 2;
}

message InteractiveTaskAllocReply {
  bool ok = 1;
  oneof payload {
    BasicTaskMeta task_meta = 2;
    string reason = 3;
  }
}

message InteractiveTaskAllocationDetail {
  /* Used to connect the SlurmXd node */
  uint32 node_index = 1;
  string ipv4_addr = 2;
  uint32 port = 3;
}

message QueryInteractiveTaskAllocDetailRequest {
  uint32 task_id = 1;
  bytes resource_uuid = 2;
}

message QueryInteractiveTaskAllocDetailReply {
  bool ok = 1;
  InteractiveTaskAllocationDetail detail = 2;
}

message TaskInfo {
  string executive_path = 1;
  repeated string arguments = 2;

  bytes resource_uuid = 3;
}

message IoRedirection {
  string buf = 1;
}

message TaskExitStatus {
  enum ExitReason {
    Normal = 0;
    Signal = 1;
  }

  ExitReason reason = 1;
  uint32 value = 2;
}

message NewlyAllocatedTaskInfo {
  uint32 job_id = 1;
}

message NewTaskResult {
  bool ok = 1;
  oneof payload{
    string reason = 2; // Set if task allocation fails.
    NewlyAllocatedTaskInfo newly_allocated_task_info = 3; // Set if task allocation succeeds.
  }
}

message SrunXStreamRequest{
  enum Type {
    NegotiationRequest = 0;
    NewTask = 1;
    Signal = 2;
  }
  Type type = 1;

  oneof payload {
    NegotiationRequest negotiation = 2;
    TaskInfo task_info = 3;
    uint32 signum = 4;
  }
}

message SrunXStreamReply {
  enum Type {
    IoRedirection = 0;
    ExitStatus = 1;
    NewTaskResult = 2;
    NegotiationReply = 3;
  }
  Type type = 1;

  oneof payload {
    IoRedirection io_redirection = 2 ;
    TaskExitStatus task_exit_status = 3;
    NewTaskResult new_task_result = 4;
    NegotiationReply negotiation_reply = 5;
  }
}

message SlurmXdRegisterRequest {
  Negotiation header = 1;

  uint32 port = 2;
  string node_name = 3;
  string partition_name = 4;

  AllocatableResource resource_total = 5;
  uint64 time_limit_for_task_in_sec = 6;

  /* Todo: Add fields describing what tasks the SlurmXd is still running and the current usage of this node in case that
      from CtlXd's view, this node is down due to network problem and however this node is still running.
  */
}

message SlurmXdRegisterResult {
  bool ok = 1;
  oneof payload {
    // If ok is true
    XdNodeId node_id = 2;

    // If ok is false, reason is set.
    string reason = 3;
  }
}

message GrantResourceTokenRequest {
  bytes resource_uuid = 1;
  AllocatableResource allocated_resource = 2;
}

message GrantResourceTokenReply {
  bool ok = 1;
  string reason = 2;
}

message RevokeResourceTokenRequest {
  bytes resource_uuid = 1;
}

message RevokeResourceTokenReply {
  bool ok = 1;
  string reason = 2;
}

message DeallocateResourceRequest {
  XdNodeId node_id = 1;
  bytes resource_uuid = 2;
}

message DeallocateResourceReply {
  bool ok = 1;
  string reason = 2 ;
}

message TaskStatusChangeRequest {
  uint32 task_id = 1;
  TaskStatus new_status = 2;
  bool release_resource = 3;
}

message TaskStatusChangeReply {
  bool ok = 1;
}

message SubmitBatchTaskRequest {
  /* --------- Fields that are shared between all types of tasks ----------------- */
  string executive_path = 1;
  repeated string arguments = 2;

  google.protobuf.Duration time_limit = 3;
  string partition_name = 4;
  Resources required_resources = 5;

  /* -------------------- Fields that are batch task only ------------------------ */
  string output_file_pattern = 6;
}

message SubmitBatchTaskReply {
  bool ok = 1;
  oneof payload{
    BasicTaskMeta task_meta = 2;
    string reason = 3;
  }
}

message ExecuteTaskRequest {
  Task task = 1;
  oneof additional_meta {
    BatchTaskAdditionalMeta batch_meta = 2;
    InteractiveTaskAdditionalMeta interactive_meta = 3;
  }
}

message ExecuteTaskReply {
  bool ok = 1;
  string reason = 2;
}

// Todo: Divide service into two parts: one for SlurmXd and one for SrunX
//  We need to distinguish the message sender
//  and have some kind of authentication
service SlurmCtlXd {
  /* RPCs called from SlurmXd*/
  rpc RegisterSlurmXd(SlurmXdRegisterRequest) returns (SlurmXdRegisterResult);
  rpc TaskStatusChange(TaskStatusChangeRequest) returns (TaskStatusChangeReply);

  /* When SlurmXd finishes executing a task, SlurmCtlXd will be informed to deallocate related resources. */
  rpc DeallocateResource(DeallocateResourceRequest) returns(DeallocateResourceReply);


  /* RPCs called from SrunX */
  /* When SrunX request an interactive job, it will first request SrunX to allocate
     an interactive task and get the related meta information. */
  rpc AllocateInteractiveTask(InteractiveTaskAllocRequest) returns(InteractiveTaskAllocReply);
  rpc QueryInteractiveTaskAllocDetail(QueryInteractiveTaskAllocDetailRequest) returns(QueryInteractiveTaskAllocDetailReply);


  /* RPCs called from sbatch */
  rpc SubmitBatchTask(SubmitBatchTaskRequest) returns(SubmitBatchTaskReply);
}

service SlurmXd {
  /* Called from SlurmCtlXd */
  rpc GrantResourceToken(GrantResourceTokenRequest) returns (GrantResourceTokenReply);
  rpc RevokeResourceToken(RevokeResourceTokenRequest) returns (RevokeResourceTokenReply);
  rpc ExecuteTask(ExecuteTaskRequest) returns(ExecuteTaskReply);

  /* Called from SrunX */
  rpc SrunXStream(stream SrunXStreamRequest) returns (stream SrunXStreamReply);
}